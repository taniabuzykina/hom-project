import numpy as np
from pulp import *
import time

vehicleLenghtsList = [42, 42, 42, 53, 53, 42, 53, 53, 53, 42, 53,
               53, 53, 42, 53, 53, 53, 42, 53, 42, 42, 53,
               53, 42, 42, 53, 42, 42, 42, 53, 42, 42, 53,
               42, 42, 42, 42, 42, 53, 42, 42, 42, 42, 42,
               42, 53, 42, 53, 42]

vehicleSeriesList = [2, 2, 2, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1,
            2, 1, 1, 1, 2, 1, 2, 2, 1, 1, 2, 2, 1,
            2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 1,
            2, 2, 2, 2, 2, 2, 1, 2, 1, 2]

vehicleDepartureTimeList = [288, 333, 345, 360, 376, 393, 396, 399, 406, 410, 425, 438, 381, 419, 397, 255,
                    257, 262, 307, 314, 324, 334, 344, 391, 400, 409, 428, 433, 442, 278, 283, 293,
                    298, 303, 308, 313, 318, 323, 341, 385, 394, 440, 351, 312, 322, 332, 342, 407, 437]

laneBlockingList = [[], [], [], [], [4], [], [], [7], [], [],
                  [10], [13, 14], [], [], [], [15], [], [], [18],
                  [], [22], [], [22], [], [24], [], [], [], []]

laneLengthList = [74, 83, 90, 97, 96, 133, 132, 132, 134, 134,
                  134, 128, 85, 88, 124, 120, 124, 107, 107, 107,
                  107, 91, 88, 85, 78, 88, 70, 66, 80]

vehicleLanePlacementList = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            ]

ScheduleType = [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 1, 1, 4, 6,
                6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0]

#############read the file ########################


def transform_to_int(elem):
    if elem == '\n': #converting string elements to int
        return 0
    else:
        return int(elem)


def read_into_solution_list(paramList):
    for i in range(29):
        inp = f.readline()
        x = inp.split(' ') if inp[-1] != ' ' else inp[:-1].split(' ')

        newx = [] #creating empty lists in order to fill them with converted to int values from each row (lane)
        for j in x:
            tr = transform_to_int(j)
            if tr != 0:
                newx.append(tr)

        paramList.append(newx) #appending the lane inputs to the array of lanes

    return paramList


####################check the constraints##################
def allKillConstraintCheck(InitialList):
    InitialList = departureTimeConstraint(InitialList)
    allKillSat = True
    allKillSat = allKillSat == sameSeriesConstraint(InitialList)
    allKillSat = allKillSat == lengthConstraint(InitialList)
    allKillSat = allKillSat == blockLanesRightChecker(InitialList)

    return allKillSat

#2. same series in one lane
def sameSeriesConstraint (CombLi):
    sat = True
    liSat = True
    for li in CombLi:
        iSat = True
        if len(li) > 1:
            for i in range(len(li)-1):
                if i < len(li)-1:
                    if vehicleSeriesList[li[i]-1] != vehicleSeriesList[li[i+1]-1]:
                        iSat = False
        liSat = liSat == iSat
    return sat == liSat


#3. length doesn't exceed
def lengthConstraint (CombLi):
    sat = True
    countSat = True
    for li in CombLi:
        liSat = True
        lengthLi = []
        if len(li)!=0:
            for i in li:
                lengthLi.append(vehicleLenghtsList[i-1])
        if (sum(lengthLi)+0.5*(len(li)-1)) > laneLengthList[CombLi.index(li)-1]:
            liSat = False
        countSat = countSat == liSat
    return sat==countSat


#4. sort by departure time
def departureTimeConstraint(CombLi):
    for li in CombLi:
        depLi = []
        if len(li)>1:
            for i in li:
                depLi.append(vehicleDepartureTimeList[i-1])
        sortedByDepartureTime = sorted(zip(li, depLi), key=lambda tup: tup[1])
        li = [i[0] for i in sortedByDepartureTime]
    return CombLi


#5. blocking lane departures
def blockLanesRightChecker(CombLi): #main blocked lanes checker
    sat = True
    for i in range(len(CombLi)):
        iSat = True
        blockedLanes = BlockingLanesConstraint(CombLi[i], i)
        blcs = True  # blcs = blocking lanes constraint satisfaction
        if len(blockedLanes) != 0: #if there are some blockedLanes, we send each of them to find out whether the time of the blocking lane is smaller than of the one that is blocked
            for jindex in blockedLanes:
                blcs = (blcs == isAheadOfBlockedLane(InitSol[i], InitSol[jindex - 1]))
        iSat= iSat == blcs
    return sat == iSat


def BlockingLanesConstraint(li, indexLi): #help function
    blockedLanesList = []
    if len(laneBlockingList[indexLi]) != 0:

        if len(laneBlockingList[indexLi]) == 1:
            blockedLanesList.append(laneBlockingList[indexLi][0])
        else:
            for i in laneBlockingList[indexLi]:
                blockedLanesList.append(i)

    return blockedLanesList


def isAheadOfBlockedLane(li1, li2): #help function
    sat = True
    if len(li1) != 0:
        if len(li2) != 0:
            if vehicleDepartureTimeList[li1[-1]-1] < vehicleDepartureTimeList[li2[0]-1]:
                sat = True
            else:
                sat = False

    return sat


#FITNESS FUNCTIONs

# AYDIN PLEASE LOOK INTO fitness_function1, IT WORKS WRONG, I checked it and it seemed right but apparently it's not
def fitness_function1(CombLi): #CombLi = list of lists i.e each sublist is a lane with vehicles on it, if a sublist is empty - no vehicle on a lane
    f1 = 0
    if len(CombLi[0]) != 0:
        SeriesNum = CombLi[0][0]
    else:
        SeriesNum = 0

    for li in CombLi:
        if len(li) != 0:
            if SeriesNum != vehicleSeriesList[li[0]-1]:
                f1 += 1
                SeriesNum = vehicleSeriesList[li[0]-1]
        else:
            if SeriesNum != 0:
                f1 += 1
                SeriesNum = 0
    return f1 /(len(CombLi)-1)


def fitness_function2(CombLi):
    f2 = 0
    for li in CombLi:
        if len(li) != 0:
            f2 += 1
    return f2/len(CombLi)


#AND ALSO LOOK INTO fitness function 3
def fitness_function3(CombLi):
    remainCapacity = 0

    for li in CombLi:

        if len(li) == 0:
            remainCapacity += laneLengthList[CombLi.index(li)]
        else:
            vhs = laneLengthList[CombLi.index(li)] #vhs = sum of all lengths of vehicles on a lane
            for i in li:
                vhs -= vehicleLenghtsList[i-1]

            remainCapacity += vhs - 0.5*(len(li) - 1)

    return remainCapacity/(sum(laneLengthList) - sum(vehicleLenghtsList))


def calculate_fitness(CombLi):
    return fitness_function1(CombLi)+fitness_function2(CombLi)+fitness_function3(CombLi)
    
    
###############################################################

InitSol = []
f = open("instances/instance1.txt_solution_num_p_3.txt", "r")
read_into_solution_list(InitSol)

#***************Checking the constraints and calculating the fitness function (f1p1+f2p2+f3p3)

print(allKillConstraintCheck(InitSol))
print(calculate_fitness(InitSol))



